import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# === CONFIGURATION ===
CSV_FILE = "PAXGUSDT_5m.csv"
START_DATE = "2025-01-01"
END_DATE = "2025-10-10"

ENTRY_TF = '15min'
EXIT_TF = '1h'

TP_TARGET = 0.01
SL_LIMIT = -0.005
FEE_RATE = 0.000

MACD_ENTRY_THRESHOLD = 0.1
MACD_MOMENTUM_MIN = 0.01

BODY_THRESHOLD = 0.001
VOLUME_MULTIPLIER = 12
COOLDOWN_BARS = 12

ANN = 252 * (24 * 60 // 5)

# === 1. LOAD DATA ===
df = pd.read_csv(CSV_FILE, index_col='Open Time', parse_dates=True)
df = df.loc[START_DATE:END_DATE]
df = df[['Open', 'High', 'Low', 'Close', 'Volume']].astype(float)
df.dropna(inplace=True)

# === 2. ENTRY SIGNALS ===
df_entry = df.resample(ENTRY_TF).agg({
    'Open': 'first', 'High': 'max', 'Low': 'min',
    'Close': 'last', 'Volume': 'sum'
}).dropna()

df_entry['EMA_12'] = df_entry['Close'].ewm(span=12).mean()
df_entry['EMA_26'] = df_entry['Close'].ewm(span=26).mean()
df_entry['MACD'] = df_entry['EMA_12'] - df_entry['EMA_26']
df_entry['MACD_signal'] = df_entry['MACD'].ewm(span=9).mean()
df_entry['MACD_hist'] = df_entry['MACD'] - df_entry['MACD_signal']
df_entry['MACD_momentum'] = df_entry['MACD_hist'].diff()

df_entry['entry_signal'] = (
    (df_entry['MACD_hist'] > MACD_ENTRY_THRESHOLD) &
    (df_entry['MACD_momentum'] > MACD_MOMENTUM_MIN)
).shift(1)

# === 3. EXIT SIGNALS ===
df_exit = df.resample(EXIT_TF).agg({
    'Open': 'first', 'High': 'max', 'Low': 'min',
    'Close': 'last', 'Volume': 'sum'
}).dropna()

# === 4. MERGE INTO MAIN DF ===
df['entry_signal'] = df_entry['entry_signal'].reindex(df.index, method='ffill')

# === 5. VOLUME ANOMALY & SMALL CANDLE ===
df['candle_body'] = (df['Close'] - df['Open']).abs() / (df['Open'] + 1e-9)
df['volume_ma'] = df['Volume'].rolling(288).mean()
df['volume_spike'] = df['Volume'] > VOLUME_MULTIPLIER * df['volume_ma']
df['small_candle'] = df['candle_body'] < BODY_THRESHOLD
df['volume_entry_signal'] = df['volume_spike'] & df['small_candle']
df['volume_exit_signal'] = df['volume_entry_signal']

# === 6. BACKTEST ===
equity = 1.0
positions, equity_curve = [], []
in_position = False
entry_price = entry_time = entry_index = None
last_exit_index = -np.inf
dates = df.index

for i in range(1, len(dates)):
    t = dates[i]
    row = df.iloc[i]
    price = row['Close']

    entry_sig = bool(row['entry_signal']) or bool(row['volume_entry_signal'])
    vol_exit = row['volume_exit_signal']

    if not in_position and entry_sig and (i - last_exit_index > COOLDOWN_BARS):
        in_position = True
        entry_price = price
        entry_time = t
        entry_index = i

    elif in_position:
        ret = (price / entry_price) - 1
        volume_exit_now = vol_exit and ret < 0

        exit_signal = (
            ret >= TP_TARGET or
            ret <= SL_LIMIT or
            volume_exit_now
        )

        if exit_signal:
            reason = (
                "Take Profit" if ret >= TP_TARGET else
                "Stop Loss" if ret <= SL_LIMIT else
                "Volume Anomaly"
            )
            raw_ret = ret
            net_ret = (1 + raw_ret) * (1 - FEE_RATE)**2 - 1
            equity *= (1 + net_ret)

            positions.append({
                'entry_time': entry_time,
                'exit_time': t,
                'entry_price': round(entry_price, 2),
                'exit_price': round(price, 2),
                'return': round(raw_ret * 100, 2),
                'net_return': round(net_ret * 100, 2),
                'exit_reason': reason
            })

            in_position = False
            last_exit_index = i

    equity_curve.append(equity)

# === 7. PERFORMANCE ===
equity_series = pd.Series(equity_curve, index=dates[-len(equity_curve):])
strat_returns = equity_series.pct_change().fillna(0)
buy_hold = df['Close'].pct_change().loc[dates[-len(equity_curve):]]

def stats(r, ann=ANN):
    r = r.dropna()
    if len(r) < 2 or np.isclose(r.std(), 0): return np.nan, np.nan, np.nan
    cum = (1 + r).cumprod()
    annret = cum.iloc[-1] ** (ann / len(r)) - 1
    sharpe = (r.mean() / r.std()) * np.sqrt(ann)
    mdd = ((cum / cum.cummax()) - 1).min()
    return annret, sharpe, mdd

ann, sh, mdd = stats(strat_returns)
bh_ann, bh_sh, bh_mdd = stats(buy_hold)

print("\n=== Résultats de la Stratégie ===")
print(f"Stratégie   : AnnRet {ann:.2%} | Sharpe {sh:.2f} | MaxDD {mdd:.2%}")
print(f"Buy & Hold  : AnnRet {bh_ann:.2%} | Sharpe {bh_sh:.2f} | MaxDD {bh_mdd:.2%}")

# === 8. PLOT ===
plt.figure(figsize=(12, 5))
(1 + strat_returns).cumprod().plot(label='Stratégie', lw=2, color='gold')
(1 + buy_hold).cumprod().plot(label='Buy & Hold', lw=2, ls='--', color='gray')
plt.title("Évolution de la performance")
plt.ylabel("Cumulative Return")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# === 9. STATISTIQUES DE TRADES ===
trades = pd.DataFrame(positions)
trades['entry_time'] = pd.to_datetime(trades['entry_time'])
trades['exit_time'] = pd.to_datetime(trades['exit_time'])
trades['duration'] = (trades['exit_time'] - trades['entry_time']).dt.total_seconds() / 60
trades['net_return_%'] = trades['net_return']

total_trades = len(trades)
wins = trades[trades['net_return'] > 0]
losses = trades[trades['net_return'] <= 0]

print("\n=== STATISTIQUES DES TRADES ===")
print(f"Nombre total de trades     : {total_trades}")
print(f"Trades gagnants            : {len(wins)}")
print(f"Trades perdants            : {len(losses)}")
print(f"Taux de réussite           : {len(wins) / total_trades * 100:.2f}%" if total_trades else "")
print(f"Gain moyen (gagnants)      : {wins['net_return_%'].mean():.2f}%" if len(wins) else "")
print(f"Perte moyenne (perdants)   : {losses['net_return_%'].mean():.2f}%" if len(losses) else "")
print(f"Gain total net             : {trades['net_return'].sum():.2f}%")
print(f"Durée moyenne des trades   : {trades['duration'].mean():.1f} min")
